name: Main Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 0' # Run at midnight every Sunday
  workflow_dispatch:

jobs:
  # Check for unauthorized agent edits to protected files
  agent-protection-check:
    name: Agent Protection Check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for protected file modifications
        continue-on-error: true # Continue pipeline even if this step fails
        run: |
          # Initialize violation flag
          VIOLATION=0
          
          # Check if .noagent file exists
          if [ ! -f .noagent ]; then
            echo "::warning::.noagent configuration file not found. Cannot enforce agent protection rules."
            exit 0
          fi
          
          # Get changed files in PR
          git fetch origin ${{ github.base_ref }}
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}..HEAD)
          
          # Extract protected files/patterns (skip comments and empty lines)
          PROTECTED_FILES=$(grep -v '^#' .noagent | grep -v '^$')
          
          # Get PR information
          PR_TITLE="${{ github.event.pull_request.title }}"
          PR_BODY="${{ github.event.pull_request.body }}"
          PR_COMMITS=$(git log --format=%B origin/${{ github.base_ref }}..HEAD)
          
          # Look for manual override tag in PR title or body
          if [[ "$PR_TITLE" == *"[HUMAN EDIT]"* ]] || [[ "$PR_BODY" == *"[HUMAN EDIT]"* ]]; then
            echo "Human edit override tag detected in PR. Skipping protected file checks."
            exit 0
          fi
          
          # Check for evidence of AI or bot-generated commits
          AI_PATTERN="automated by|copilot change|agent modification|\[bot\]|auto-generated|ai-assisted|generated by|created by ai|suggested by|co-authored by"
          
          # Check commit messages for AI patterns
          if echo "$PR_COMMITS" | grep -iE "$AI_PATTERN" > /dev/null; then
            echo "Detected potentially automated commits. Checking for protected file modifications..."
            
            # Look for modified protected files
            for file in $CHANGED_FILES; do
              for pattern in $PROTECTED_FILES; do
                # Check if file matches pattern (handle glob patterns)
                if [[ "$file" == $pattern ]] || [[ "$file" == $(eval echo $pattern) ]]; then
                  echo "::warning::Protected file '$file' was modified in what appears to be an automated commit."
                  echo "Evidence: Commit message contains AI/bot-related terms"
                  VIOLATION=1
                  break
                fi
              done
            done
          fi
          
          # Issue a warning instead of failing if violations found
          if [[ "$VIOLATION" -eq 1 ]]; then
            echo "::warning::Protected files were modified by what appears to be an automated process."
            echo "::warning::If this is a legitimate human edit, please add [HUMAN EDIT] to your PR title or description."
          else
            echo "No evidence of automated modifications to protected files detected. Approved."
          fi

  # Check for changelog entry in PR and create if missing
  verify-changelog:
    name: Verify or Create Changelog Entry
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: [agent-protection-check]
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref }}  # Explicitly checkout the PR branch
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get PR info
        id: pr
        run: |
          echo "number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "title=${{ github.event.pull_request.title }}" >> $GITHUB_OUTPUT

      - name: Check for changelog entry
        id: check_changelog
        run: |
          PR_NUMBER="${{ steps.pr.outputs.number }}"
          CHANGELOG_FILE=".changelog/pr-${PR_NUMBER}.txt"
          
          if [ -f "$CHANGELOG_FILE" ]; then
            echo "Changelog file $CHANGELOG_FILE exists"
            echo "exists=true" >> $GITHUB_OUTPUT
            
            # Check if the description exceeds 95 characters
            # Extract the description from between the triple backticks
            DESCRIPTION=$(grep -v "^\`\`\`" "$CHANGELOG_FILE" | tr -d '\n')
            CHAR_COUNT=${#DESCRIPTION}
            
            if [ $CHAR_COUNT -gt 95 ]; then
              echo "::warning::Changelog description exceeds the 95-character limit ($CHAR_COUNT characters)."
              echo "Please edit $CHANGELOG_FILE and shorten the description to 95 characters or less."
              echo "description_too_long=true" >> $GITHUB_OUTPUT
            else
              echo "Changelog description is within the 95-character limit ($CHAR_COUNT characters)."
              echo "description_too_long=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "Changelog file $CHANGELOG_FILE does not exist"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "description_too_long=false" >> $GITHUB_OUTPUT
          fi

      - name: Create changelog entry if missing
        if: steps.check_changelog.outputs.exists == 'false'
        run: |
          PR_NUMBER="${{ steps.pr.outputs.number }}"
          PR_TITLE="${{ steps.pr.outputs.title }}"
          CHANGELOG_FILE=".changelog/pr-${PR_NUMBER}.txt"
          
          # Create changelog directory if it doesn't exist
          mkdir -p .changelog
          
          # Determine the type of change based on PR title
          # This is a simple heuristic and can be improved
          if [[ "$PR_TITLE" == *"fix"* || "$PR_TITLE" == *"Fix"* ]]; then
            CHANGE_TYPE="bug"
            MESSAGE="Fixed issue: ${PR_TITLE}"
          elif [[ "$PR_TITLE" == *"feat"* || "$PR_TITLE" == *"Feat"* || "$PR_TITLE" == *"Add"* || "$PR_TITLE" == *"add"* ]]; then
            CHANGE_TYPE="feature"
            MESSAGE="Added feature: ${PR_TITLE}"
          elif [[ "$PR_TITLE" == *"break"* || "$PR_TITLE" == *"Break"* ]]; then
            CHANGE_TYPE="breaking-change"
            MESSAGE="Breaking change: ${PR_TITLE}"
          elif [[ "$PR_TITLE" == *"security"* || "$PR_TITLE" == *"Security"* ]]; then
            CHANGE_TYPE="security"
            MESSAGE="Security improvement: ${PR_TITLE}"
          elif [[ "$PR_TITLE" == *"deprecat"* || "$PR_TITLE" == *"Deprecat"* ]]; then
            CHANGE_TYPE="deprecation"
            MESSAGE="Deprecation: ${PR_TITLE}"
          else
            CHANGE_TYPE="enhancement"
            MESSAGE="Enhancement: ${PR_TITLE}"
          fi
          
          # Check if the PR title contains a Jira ticket reference (CDI-## or PDI-##)
          if [[ "$PR_TITLE" =~ (CDI-[0-9]+|PDI-[0-9]+) ]]; then
            JIRA_TICKET="${BASH_REMATCH[0]}"
            # Remove the Jira ticket from the message to avoid duplication
            MESSAGE=$(echo "$MESSAGE" | sed -E "s/(CDI-[0-9]+|PDI-[0-9]+)//g" | sed -E "s/^[[:space:]]+|[[:space:]]+$//g")
            # Add the Jira ticket at the end
            MESSAGE="$MESSAGE $JIRA_TICKET"
          else
            # If no Jira ticket is found, add a placeholder ticket
            # This is just for demonstration, in real workflow you might want to make this optional
            JIRA_TICKET="CDI-000"
            MESSAGE="$MESSAGE $JIRA_TICKET"
          fi
          
          # Truncate message to 95 characters if longer
          if [ ${#MESSAGE} -gt 95 ]; then
            MESSAGE="${MESSAGE:0:92}..."
            echo "Message truncated to 95 characters"
          fi
          
          # Create the changelog file with template content
          echo '```release-note:'"${CHANGE_TYPE}" > "$CHANGELOG_FILE"
          echo "${MESSAGE}" >> "$CHANGELOG_FILE"
          echo '```' >> "$CHANGELOG_FILE"
          
          echo "Created changelog file $CHANGELOG_FILE"
          
          # Commit the new changelog file
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add "$CHANGELOG_FILE"
          git commit -m "Add changelog entry for PR #${PR_NUMBER}"
          git push

      - name: Comment on PR if changelog was created
        if: steps.check_changelog.outputs.exists == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const body = [
              `âœ… I've automatically created a changelog entry for this PR in .changelog/pr-${prNumber}.txt.`,
              '',
              'Please review and update the changelog entry if needed to better describe the changes in this PR. You can edit the file directly from GitHub or in your local repository.',
              '',
              '**Note:** The description in the changelog entry must be 95 characters or less. If your description is longer, it will be automatically truncated.',
              '',
              '**Important:** Make sure your changelog entry includes a valid Jira ticket (CDI-## or PDI-##) at the end of the description. This is required for the release notes format.',
              '',
              'The changelog entry is used to generate release notes when a new version is released.'
            ].join('\n');
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body
            });
  # Linting job (Go and Shell)
  lint:
    name: Lint
    runs-on: ubuntu-latest
    needs: [verify-changelog]
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      # Go linting is not run in CI. Please run 'make devcheck' locally before pushing changes.
      - name: Linting instructions
        run: |
          echo "Go linting is not enforced in CI. Please run 'make devcheck' locally before pushing."

      - name: Install shellcheck
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck

      - name: Run shellcheck
        run: |
          SCRIPTS=$(find . -name "*.sh" -type f | sort)
          SCRIPTS+=" $(find . -type f ! -path "*/\.*" ! -path "*/vendor/*" ! -path "*/node_modules/*" -perm +111 -exec grep -l '^\#\!/bin/bash\|^\#\!/usr/bin/env bash\|^\#\!/bin/sh' {} \; 2>/dev/null | sort -u || true)"
          for script in $SCRIPTS; do
            echo "Checking $script"
            shellcheck -x "$script" || exit 1
          done

      - name: Install shfmt
        run: |
          go install mvdan.cc/sh/v3/cmd/shfmt@latest
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Run shfmt
        run: |
          SCRIPTS=$(find . -name "*.sh" -type f | sort)
          SCRIPTS+=" $(find . -type f ! -path "*/\.*" ! -path "*/vendor/*" ! -path "*/node_modules/*" -perm +111 -exec grep -l '^\#\!/bin/bash\|^\#\!/usr/bin/env bash\|^\#\!/bin/sh' {} \; 2>/dev/null | sort -u || true)"
          for script in $SCRIPTS; do
            echo "Checking $script"
            shfmt -i 2 -ci -bn -s -d "$script" || exit 1
          done

  # Basic CI testing job
  test:
    name: Unit Tests
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.5'

      - name: Get dependencies
        run: go mod download

      - name: Run unit tests
        run: go test -v -short ./...

  # Integration testing job
  integration-test:
    name: Integration Tests
    needs: lint
    runs-on: ubuntu-latest
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.5'

      - name: Get dependencies
        run: go mod download
        
      - name: Build binary for testing
        run: go build -o bin/mathreleaser-test ./cmd/mathreleaser
        
      - name: Run integration tests
        run: ./scripts/run-integration-tests.sh

  # Security scanning job - combines GoSec, govulncheck, and partial CodeQL setup
  security-scan:
    name: Security Scan
    needs: [test, integration-test]
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.5'

      - name: Get dependencies
        run: go mod download

      # GoSec security scanning
      - name: Run GoSec Security Scanner
        run: |
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          # First run with text output to see issues in logs
          gosec -no-fail ./...
          # Then run with SARIF output for GitHub security dashboard integration
          # Continue-on-error flag ensures workflow doesn't fail if security issues are found
          gosec -fmt=sarif -out=gosec.sarif ./... || echo "::warning::Security issues found, but continuing pipeline"
        
      - name: Upload GoSec scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: gosec.sarif

      # Vulnerability checking
      - name: Run govulncheck
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          # Set GOVERSION environment variable to ensure compatibility with Go 1.24
          GOVERSION=go1.24.5 govulncheck ./... || echo "::warning::Vulnerabilities found, but continuing pipeline"

  # CodeQL analysis job
  codeql-analysis:
    name: CodeQL Analysis
    needs: [test, integration-test]
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: go

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3